### String

*Напишем класс динамической саморасширяющейся строки, заодно познакомимся со стандартным классом `std::string`*.

##### `std::string`

Класс `std::string` предоставляет удобный и безопасный интерфейс работы со строками в C++. Одна из главных проблем
стековых и выделяемых в куче строк (массивов `char`) заключается в том, что они имеют фиксированный размер и не умеют
автоматически расширяться при необходимости. При создании строк в динамической области возникает потребность
в ручном отслеживании возможных утечек памяти, что накладывает дополнительные сложности на процесс разработки. Кроме
того, C-style строки не хранят информацию о своем размере, что тоже не упрощает взаимодействие с ними.

Эти проблемы можно обойти, используя ООП функционал C++. В частности, механизм инкапсуляции позволяет хранить размер
строки в отдельном поле, можно реализовать методы, при вызове которых массив будет автоматически расширяться, создавая иллюзию
неограниченной строки, а механизмы работы с ресурсами (вспоминаем **RAII**) гарантируют своевременное выделение и очищение памяти.

**Пример:***
```c++
std::string s = "hello";
s.size();        // 5, работает за O(1)
s[0] = 'H';
s += ", world!"  // строка расширяется
std::cout << s;  // "Hello, world!"
```

Подробнее о возможностях `std::string` [здесь](https://en.cppreference.com/w/cpp/string/basic_string).

##### Задание

Реализуйте класс динамической строки — аналог `std::string`, с эффективной стратегией расширения [(мультипликативная
схема)](https://en.wikipedia.org/wiki/Dynamic_array#Geometric_expansion_and_amortized_cost).

Введем понятия "размера" строки (size) и ее "вместимости" (capacity). С++ в каждый момент времени позволяет поддерживать
массивы конечной *вместимости* (сколько выделено памяти), при этом фактический *размер* (количество реально используемых
символов) может быть меньше этого значения. Почему бы постоянно не поддерживать равенство между этими величинами? — Это
неэффективно. Допустим, мы добавляем символы в конец строки по одному. Тогда при каждом добавлении будет происходить
перевыделение памяти с последующим копированием всех старых элементов в новую область. Легко видеть, что в этом
случае общее число копирований будет квадратичным образом зависеть от числа добавленных элементов. Оказывается, что,
если при каждом переполнении массива увеличивать его вместимость в константное число раз, то можно добиться линейной
зависимости числа операций над массивом от числа добавляемых элементов. В вашем решении будет проверяться корректность
работы данной схемы при множителе равном 2 (то есть, при "переполнении" строки её вместимость должна увеличиваться
**минимум в 2 раза**).

##### Детали реализации

Реализуйте класс `String` со следующим интерфейсом:
* Конструктор по умолчанию — создает пустую строку (`nullptr`);
* Конструктор, принимающий `size` и `symbol`, — создает строку длины `size`, заполненную символами `symbol`.
* Конструктор, принимающий С-style строку (`const char*`) и создающий на её основе строку. Этот конструктор должен уметь
выполнять неявные преобразования, поэтому не нужно объявлять его `explicit`. Это не понравится статическому анализатору кода,
поэтому к строке с объявлением добавьте комментарий `// NOLINT`, чтобы он проигнорировал эту строку.
* Конструктор, принимающий массив `char` (`const char*`) и количество первых символов (`size`), которые нужно
скопировать.
* Правило "пяти".
* Константную и неконстантную операцию доступа по индексу `[]`;  последняя должна позволять изменять полученный символ.
* Константный и неконстантный метод доступа по индексу `At`. При выходе за границы строки он должен бросать исключение
`StringOutOfRange`, которое уже написано за вас.
* Методы `Front()` и `Back()` — доступ к первому и последнему символам (тоже по две версии).
* Методы `CStr()` и `Data()` — возвращают **константный** и обычный указатели на начало строки (C-style строку).
* Метод `Empty()` — `true`, если строка пуста (размер 0).
* Методы `Size()` и `Length()` — размер строки.
* Метод `Capacity()` — текущая вместимость.
* Метод `Clear()` — "ощичает" строку (устанавливает размер в 0), удаления выделенной памяти при этом НЕ происходит.
* Метод `Swap(other)` — обменивает содержимое с другой строкой `other`.
* Метод `PopBack()` — удаляет последний символ.
* Метод `PushBack(symbol)` — добавляет символ `symbol` в конец строки (при необходимости строка расширяется).
* Операция `+=` — принимает другую строку (`String`) и приписывает ее в конец текущей.
* Метод `Resize(new_size, symbol)` — изменяет размер на `new_size`. Если вместимость не позволяет хранить столько
символов, то выделяется новый буфер с вместимостью `new_size`. В случае `new_size > size` заполняет недостающие
символы значением `symbol`.
* Метод `Reserve(new_capacity)` — изменяет вместимость на `max(new_capacity, текущая вместимость)`. Размер при этом не
изменяется.
* Метод `ShrinkToFit()` — уменьшает `capacity` до `size` (убирает излишек).
* Конкатенация с помощью операции `+`.
* Операции сравнения (`<`, `>`, `<=`, `>=`, `==`, `!=`), задающие лексикографический порядок.
* Операции чтения из потока и записи в поток (подробности далее).

Если строка реализована ~~правильно~~ так, как предполагали авторы, то реализация вывода в поток должна быть
тривиальной. Ввод из потока должен осуществляться по следующим правилам:
* все пробельные символы в начале потока должны быть пропущены;
* ввод строки заканчивается при первом встреченном пробельном символе (за исключением символов в начале потока).
Для чтения одного символа из потока используется метод
[`std::istream::get` (2)](https://en.cppreference.com/w/cpp/io/basic_istream/get), результат вызова которого можно
использовать для проверки закончился поток или нет (например, `while (std::cin.get(symbol))`). Для проверки является ли
символ пробельным предлагается использовать [`std::isspace`](https://en.cppreference.com/w/cpp/string/byte/isspace).
**Обратите внимание:** `std::isspace` ожидает на вход `unsigned char`, поэтому при проверке символа не забывайте
использовать `static_cast<unsigned char>`. Считанные символы можно добавлять по одному с помощью `PushBack`.

**Замечания.**

1. Решение должно состоять из файлов `string.hpp` и `string.cpp`.
2. Можно использовать функции из `<cstring>`.
3. Проверка устроена таким образом, что требует от вас жесткого следования принятым (выше) сигнатурам и именованиям
сущностей (то есть никакие `MyString`, `__string_`, `push_back`, `superSolver3000` не пройдут). Если вы реализовали
требуемый функционал не полностью или интерфейс отличается от заявленного, вы получите ошибку компиляции.
4. В тесты включены проверки функциональности (методы работают так как требует условие), проверка эффективности
реализации (что значит эффективно — описано выше), проверка корректности работы с памятью (утечки памяти, обращения к
памяти, не принадлежащей процессу будут приводить к ошибке).
