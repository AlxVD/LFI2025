### MatrixArray

*В этом задании вам необходимо реализовать шаблонный класс для работы с матрицами фиксированного размера. Последнее
означает, что размеры матрицы должны передаваться в виде шаблонных параметров-целых чисел (non-type template
parameters), и для конкретного объекта не могут быть изменены в течении работы программы. С одной стороны, это
накладывает ограничения — размер матриц должен быть жестко задан на этапе компиляции и пользователь не имеет возможности
его менять. Кроме того, изменения параметров матриц будут требовать повторной компиляции исходного кода, использующего
эти матрицы. С другой стороны, так как размеры матрицы — константы времени компиляции, мы имеем возможность использовать
нединамические массивы (что заметно ускоряет работу с матрицами), компилятор имеет больше возможностей для оптимизации
кода, а неправильная работа с матрицами (умножение матриц неподходящих размеров, обращение неквадратных матриц и т.п.)
будет обнаружена ещё на этапе компиляции программы, а не во время исполнения.*

#### Детали реализации

Требуется реализовать шаблонный класс `Matrix`, принимающий в качестве шаблонных параметров тип хранимых элементов,
число строк матрицы и число столбцов. Так как шаблонные параметры — это константы времени компиляции, элементы матрицы
можно хранить в двумерном C-style массиве (впрочем, можно воспользоваться и `std::array`). Это поле-массив должно быть
публичным для корректной работы агрегатной инициализации.

Для работы с матрицей предлагается реализовать следующие методы:
* `RowsNumber()` и `ColumnsNumber()`, возвращающие число строк и столбцов соответственно;
* Операция `()` ("круглые скобки") для доступа к элементам матрицы (возможность передавать несколько аргументов в `[]`
  появилась только в C++23, мы этот функционал пока не будем использовать);
* Метод `At`, аналогичный предыдущему пункту, но бросающий исключение `MatrixOutOfRange` в случае выхода за границы
  матрицы;
* Функцию `GetTransposed(matrix)`, возвращающую транспонированную версию переданной матрицы;
* Операции сложения, вычитания умножения матриц и их присваивающие версии. Обратите внимание, что эти операции применимы
  не к любым парам матриц!;
* Операции умножения (слева и справа) и деления на число, а также их присваивающие версии;
* Операции сравнения на равенство и неравенство двух матриц одинакового размера;
* Операции ввода из потока и вывода в поток.

Пример:

```c++
Matrix<int, 2, 3> a{{{1, 2, 3}, {4, 5, 6}}};
Matrix<int, 3, 2> b = GetTransposed(a);
// a + b      CE
a + a;     // Ok
// a * a      CE 
a * b;     // Ok
// a *= b  // CE - в матрицу a нельзя присвоить матрицу другого размера
b *= Matrix<int, 2, 2>{1, 2, 3, 4}; // Ok

std::cout << a;
```

```
1 2 3
4 5 6
```

**Замечания.**

1. Решение должно состоять из одного файла `matrix.hpp`.
2. Помните о константных и неконстантных методах (так же используем спецификаторы *noexcept*, *constexpr*, атрибут *[[nodiscard]]*).
3. Методы этого и дополнительного задания (ниже) необязательно реализовывать наиболее эффективным способом. В первую
   очередь проверяется правильность реализации (т.е. для того же детерминанта подойдёт рекурсивная реализация).
4. "Бросить исключение типа E" значит - написать строку throw E{};. В этот момент выполнение функции прекращается и,
   если исключение не будет обработано, программа завершится аварийно. Тестирующий код корректно обработает эту ошибку, вам
   этого делать не нужно.
5. В задаче нет скрытых тестов — все тесты публичные (`matrix_test.cpp`).

---

### Дополнительная часть

Для работы с квадратными матрицами есть множество методов неприменимых к матрицам произвольного размера. Но так как размеры матриц известны заранее, мы можем ещё на этапе компиляции провериь корректность.

Дополнительно реализуйте:

* Функцию `Transpose(matrix)`, которая транспонирует *исходную* матрицу, изменяя ее (ясно, что транспонировать без
  изменения размера можно только квадратные матрицы);
* Функцию `Trace(matrix)` — подсчет следа матрицы;
* Функцию `Determinant(matrix)` — детерминант матрицы;
* Функции `GetInversed(matrix)` и `Inverse(matrix)` для обращения матриц (первый метод возвращает обратную, а второй —
  изменяет исходную матрицу).

При попытке обращения вырожденной матрицы необходимо бросать исключение `MatrixIsDegenerateError`.

*Важно 1:* Приступайте к тестированию этой части только после решения задачи *Rational* (она используется в тестах).

*Важно 2:* Если вы выполнили это задание, добавьте в файл `matrix.hpp` следующую строку, чтобы в тесты была включена
проверка этого задания.

```c++
#define MATRIX_SQUARE_MATRIX_IMPLEMENTED
```
